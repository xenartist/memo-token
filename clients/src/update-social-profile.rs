use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    signature::{read_keypair_file, Signer},
    pubkey::Pubkey,
    instruction::{AccountMeta, Instruction},
    transaction::Transaction,
    compute_budget::ComputeBudgetInstruction,
};
use std::str::FromStr;
use borsh::{BorshSerialize, BorshDeserialize};

// Discriminator for update_social_profile instruction
// be careful, this value needs to be updated according to the IDL generated by the actual deployed contract
const UPDATE_SOCIAL_PROFILE_DISCRIMINATOR: [u8; 8] = [35,235,34,151,218,214,96,78];

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // get command line arguments
    let args: Vec<String> = std::env::args().collect();
    
    if args.len() < 2 {
        println!("Usage: cargo run --bin update-social-profile [username NEW_USERNAME] [image NEW_IMAGE] [about \"NEW ABOUT ME\"]");
        println!("Example: cargo run --bin update-social-profile username \"NewName\" image \"n:123456\" about \"Hello world\"");
        println!("Note: At least one of the options must be provided");
        return Ok(());
    }
    
    // parse command line arguments
    let mut username = None;
    let mut profile_image = None;
    let mut about_me = None;
    
    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "username" => {
                if i + 1 < args.len() {
                    username = Some(args[i + 1].clone());
                    if username.as_ref().unwrap().len() > 32 {
                        return Err("Username too long. Maximum length is 32 characters".into());
                    }
                    i += 2;
                } else {
                    return Err("Missing username value".into());
                }
            },
            "image" => {
                if i + 1 < args.len() {
                    profile_image = Some(args[i + 1].clone());
                    if profile_image.as_ref().unwrap().len() > 256 {
                        return Err("Profile image too long. Maximum length is 256 characters".into());
                    }
                    i += 2;
                } else {
                    return Err("Missing profile image value".into());
                }
            },
            "about" => {
                if i + 1 < args.len() {
                    about_me = Some(args[i + 1].clone());
                    if about_me.as_ref().unwrap().len() > 128 {
                        return Err("About me too long. Maximum length is 128 characters".into());
                    }
                    i += 2;
                } else {
                    return Err("Missing about me value".into());
                }
            },
            _ => {
                return Err(format!("Unknown option: {}", args[i]).into());
            }
        }
    }
    
    // ensure at least one option is provided
    if username.is_none() && profile_image.is_none() && about_me.is_none() {
        return Err("At least one of username, image, or about must be provided".into());
    }
    
    // connect to network
    let rpc_url = "https://rpc.testnet.x1.xyz";
    let client = RpcClient::new(rpc_url);

    // load wallet
    let payer = read_keypair_file(
        shellexpand::tilde("~/.config/solana/id.json").to_string()
    ).expect("Failed to read keypair file");

    // Program ID - memo-social contract ID
    let program_id = Pubkey::from_str("CamUGqtEX8knHJ9a4jBeo3hBmdE2pWonbiFjBgyEG92q")
        .expect("Invalid program ID");
    
    // calculate social profile PDA
    let (social_profile_pda, _) = Pubkey::find_program_address(
        &[b"social_profile", payer.pubkey().as_ref()],
        &program_id,
    );
    
    println!("Updating social profile for: {}", payer.pubkey());
    println!("Social profile PDA: {}", social_profile_pda);
    
    // check if social profile exists
    match client.get_account(&social_profile_pda) {
        Ok(_) => {
            println!("Found existing social profile.");
        },
        Err(_) => {
            println!("No social profile found. Please create one first using 'init-social-profile'.");
            return Ok(());
        }
    }
    
    // prepare instruction data
    let mut instruction_data = Vec::new();
    
    // write discriminator
    instruction_data.extend_from_slice(&UPDATE_SOCIAL_PROFILE_DISCRIMINATOR);
    
    // serialize username parameter (Option<String>)
    if let Some(name) = &username {
        // Some variant (1)
        instruction_data.push(1);
        // String content
        instruction_data.extend_from_slice(&(name.len() as u32).to_le_bytes());
        instruction_data.extend_from_slice(name.as_bytes());
    } else {
        // None variant (0)
        instruction_data.push(0);
    }
    
    // serialize profile_image parameter (Option<String>)
    if let Some(image) = &profile_image {
        // Some variant (1)
        instruction_data.push(1);
        // String content
        instruction_data.extend_from_slice(&(image.len() as u32).to_le_bytes());
        instruction_data.extend_from_slice(image.as_bytes());
    } else {
        // None variant (0)
        instruction_data.push(0);
    }
    
    // serialize about_me parameter (Option<String>)
    if let Some(about) = &about_me {
        // Some variant (1)
        instruction_data.push(1);
        // String content
        instruction_data.extend_from_slice(&(about.len() as u32).to_le_bytes());
        instruction_data.extend_from_slice(about.as_bytes());
    } else {
        // None variant (0)
        instruction_data.push(0);
    }
    
    // print update details
    println!("\nUpdating profile with the following details:");
    if let Some(name) = &username {
        println!("Username: {}", name);
    }
    if let Some(image) = &profile_image {
        println!("Profile Image: {}", image);
    }
    if let Some(about) = &about_me {
        println!("About Me: {}", about);
    }
    
    // create update social profile instruction
    let update_social_profile_ix = Instruction::new_with_bytes(
        program_id,
        &instruction_data,
        vec![
            AccountMeta::new(payer.pubkey(), true), // user (signer, writable)
            AccountMeta::new(social_profile_pda, false), // social_profile (writable)
            AccountMeta::new_readonly(solana_sdk::system_program::id(), false), // system_program
        ],
    );
    
    // set compute budget to avoid insufficient compute error
    let compute_budget_ix = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    
    // get latest block hash
    let recent_blockhash = client.get_latest_blockhash()?;
    
    // create transaction
    let transaction = Transaction::new_signed_with_payer(
        &[compute_budget_ix, update_social_profile_ix],
        Some(&payer.pubkey()),
        &[&payer],
        recent_blockhash,
    );
    
    // send and confirm transaction
    println!("Sending transaction...");
    
    match client.send_and_confirm_transaction_with_spinner(&transaction) {
        Ok(signature) => {
            println!("\nTransaction was successful!");
            println!("Signature: {}", signature);
            println!("Social profile updated successfully.");
        },
        Err(err) => {
            println!("Error: {}", err);
            return Err(err.into());
        }
    }
    
    Ok(())
}
