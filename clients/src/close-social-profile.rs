use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    signature::{read_keypair_file, Signer},
    pubkey::Pubkey,
    instruction::{AccountMeta, Instruction},
    transaction::Transaction,
    compute_budget::ComputeBudgetInstruction,
};
use std::str::FromStr;

// Discriminator for close_social_profile instruction
// be careful, this value needs to be updated according to the IDL generated by the actual deployed contract
const CLOSE_SOCIAL_PROFILE_DISCRIMINATOR: [u8; 8] = [190,173,191,13,177,144,116,78];

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // connect to network
    let rpc_url = "https://rpc.testnet.x1.xyz";
    let client = RpcClient::new(rpc_url);

    // load wallet
    let payer = read_keypair_file(
        shellexpand::tilde("~/.config/solana/id.json").to_string()
    ).expect("Failed to read keypair file");

    // Program ID - memo-social contract ID
    let program_id = Pubkey::from_str("CamUGqtEX8knHJ9a4jBeo3hBmdE2pWonbiFjBgyEG92q")
        .expect("Invalid program ID");
    
    // calculate social profile PDA
    let (social_profile_pda, _) = Pubkey::find_program_address(
        &[b"social_profile", payer.pubkey().as_ref()],
        &program_id,
    );
    
    println!("Checking social profile for: {}", payer.pubkey());
    println!("Social profile PDA: {}", social_profile_pda);
    
    // check if social profile exists
    match client.get_account(&social_profile_pda) {
        Ok(account) => {
            println!("Found existing social profile.");
            println!("Account balance: {} SOL", account.lamports as f64 / 1_000_000_000.0);
        },
        Err(_) => {
            println!("No social profile found for this wallet.");
            return Ok(());
        }
    }
    
    // ask user to confirm
    println!("\nWARNING: This will permanently delete your social profile.");
    println!("The account rent will be returned to your wallet.");
    println!("Type 'confirm' to proceed:");
    
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    
    if input.trim() != "confirm" {
        println!("Operation cancelled.");
        return Ok(());
    }
    
    // prepare instruction data
    let mut instruction_data = Vec::new();
    
    // write discriminator
    instruction_data.extend_from_slice(&CLOSE_SOCIAL_PROFILE_DISCRIMINATOR);
    
    // create close social profile instruction
    let close_social_profile_ix = Instruction::new_with_bytes(
        program_id,
        &instruction_data,
        vec![
            AccountMeta::new(payer.pubkey(), true), // user (signer, writable)
            AccountMeta::new(social_profile_pda, false), // social_profile (writable)
            AccountMeta::new_readonly(solana_sdk::system_program::id(), false), // system_program
        ],
    );
    
    // set compute budget to avoid insufficient compute error
    let compute_budget_ix = ComputeBudgetInstruction::set_compute_unit_limit(300_000);
    
    // get latest block hash
    let recent_blockhash = client.get_latest_blockhash()?;
    
    // create transaction
    let transaction = Transaction::new_signed_with_payer(
        &[compute_budget_ix, close_social_profile_ix],
        Some(&payer.pubkey()),
        &[&payer],
        recent_blockhash,
    );
    
    // send and confirm transaction
    println!("Sending transaction to close social profile...");
    
    match client.send_and_confirm_transaction_with_spinner(&transaction) {
        Ok(signature) => {
            println!("\nTransaction was successful!");
            println!("Signature: {}", signature);
            println!("Social profile closed successfully.");
            println!("Account rent has been returned to your wallet.");
        },
        Err(err) => {
            println!("Error: {}", err);
            return Err(err.into());
        }
    }
    
    Ok(())
}
