use solana_client::{
    rpc_client::RpcClient,
    rpc_config::RpcSimulateTransactionConfig,
};
use solana_sdk::{
    signature::{read_keypair_file, Signer},
    pubkey::Pubkey,
    instruction::{AccountMeta, Instruction},
    transaction::Transaction,
    compute_budget::ComputeBudgetInstruction,
    commitment_config::CommitmentConfig,
};
use std::str::FromStr;

// Discriminator for close_social_profile instruction
// be careful, this value needs to be updated according to the IDL generated by the actual deployed contract
const CLOSE_SOCIAL_PROFILE_DISCRIMINATOR: [u8; 8] = [190,173,191,13,177,144,116,78];

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // connect to network
    let rpc_url = "https://rpc.testnet.x1.xyz";
    let client = RpcClient::new(rpc_url);

    // load wallet
    let payer = read_keypair_file(
        shellexpand::tilde("~/.config/solana/id.json").to_string()
    ).expect("Failed to read keypair file");

    // Program ID - memo-social contract ID
    let program_id = Pubkey::from_str("CamUGqtEX8knHJ9a4jBeo3hBmdE2pWonbiFjBgyEG92q")
        .expect("Invalid program ID");
    
    // calculate social profile PDA
    let (social_profile_pda, _) = Pubkey::find_program_address(
        &[b"social_profile", payer.pubkey().as_ref()],
        &program_id,
    );
    
    println!("Checking social profile for: {}", payer.pubkey());
    println!("Social profile PDA: {}", social_profile_pda);
    
    // check if social profile exists
    match client.get_account(&social_profile_pda) {
        Ok(account) => {
            println!("Found existing social profile.");
            println!("Account balance: {} SOL", account.lamports as f64 / 1_000_000_000.0);
        },
        Err(_) => {
            println!("No social profile found for this wallet.");
            return Ok(());
        }
    }
    
    // ask user to confirm
    println!("\nWARNING: This will permanently delete your social profile.");
    println!("The account rent will be returned to your wallet.");
    println!("Type 'confirm' to proceed:");
    
    let mut input = String::new();
    std::io::stdin().read_line(&mut input)?;
    
    if input.trim() != "confirm" {
        println!("Operation cancelled.");
        return Ok(());
    }
    
    // prepare instruction data
    let mut instruction_data = Vec::new();
    
    // write discriminator
    instruction_data.extend_from_slice(&CLOSE_SOCIAL_PROFILE_DISCRIMINATOR);
    
    // create close social profile instruction
    let close_social_profile_ix = Instruction::new_with_bytes(
        program_id,
        &instruction_data,
        vec![
            AccountMeta::new(payer.pubkey(), true), // user (signer, writable)
            AccountMeta::new(social_profile_pda, false), // social_profile (writable)
            AccountMeta::new_readonly(solana_sdk::system_program::id(), false), // system_program
        ],
    );
    
    // Default compute units as fallback
    let initial_compute_units = 300_000;
    
    // get latest block hash
    let recent_blockhash = client.get_latest_blockhash()?;
    
    // Create transaction without compute budget instruction for simulation
    let sim_transaction = Transaction::new_signed_with_payer(
        &[close_social_profile_ix.clone()],
        Some(&payer.pubkey()),
        &[&payer],
        recent_blockhash,
    );
    
    // Simulate transaction to determine required compute units
    println!("Simulating transaction to determine required compute units...");
    let compute_units = match client.simulate_transaction_with_config(
        &sim_transaction,
        RpcSimulateTransactionConfig {
            sig_verify: false,
            replace_recent_blockhash: false,
            commitment: Some(CommitmentConfig::confirmed()),
            encoding: None,
            accounts: None,
            min_context_slot: None,
            inner_instructions: true,
        },
    ) {
        Ok(result) => {
            if let Some(err) = result.value.err {
                println!("Warning: Transaction simulation failed: {:?}", err);
                println!("Using default compute units: {}", initial_compute_units);
                initial_compute_units
            } else if let Some(units_consumed) = result.value.units_consumed {
                // Add 10% safety margin
                let required_cu = (units_consumed as f64 * 1.1) as u32;
                println!("Simulation consumed {} CUs, requesting {} CUs with 10% safety margin", 
                    units_consumed, required_cu);
                required_cu
            } else {
                println!("Simulation didn't return units consumed, using default: {}", initial_compute_units);
                initial_compute_units
            }
        },
        Err(err) => {
            println!("Failed to simulate transaction: {}", err);
            println!("Using default compute units: {}", initial_compute_units);
            initial_compute_units
        }
    };
    
    // Create compute budget instruction with dynamically calculated CU
    let compute_budget_ix = ComputeBudgetInstruction::set_compute_unit_limit(compute_units);
    println!("Setting compute budget: {} CUs", compute_units);
    
    // create transaction with updated compute units
    let transaction = Transaction::new_signed_with_payer(
        &[compute_budget_ix, close_social_profile_ix],
        Some(&payer.pubkey()),
        &[&payer],
        recent_blockhash,
    );
    
    // send and confirm transaction
    println!("Sending transaction to close social profile...");
    
    match client.send_and_confirm_transaction_with_spinner(&transaction) {
        Ok(signature) => {
            println!("\nTransaction was successful!");
            println!("Signature: {}", signature);
            println!("Social profile closed successfully.");
            println!("Account rent has been returned to your wallet.");
        },
        Err(err) => {
            println!("Error: {}", err);
            return Err(err.into());
        }
    }
    
    Ok(())
}
